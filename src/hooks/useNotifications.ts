import { useState, useEffect, useCallback } from 'react';
import { supabase } from '../lib/supabase';
import toast from 'react-hot-toast';

interface Notification {
  id: string;
  title: string;
  message: string;
  type: 'info' | 'success' | 'warning' | 'error';
  category: 'sales' | 'inventory' | 'expiry' | 'security' | 'system' | 'general';
  priority: 'low' | 'normal' | 'high' | 'urgent';
  isRead: boolean;
  autoGenerated: boolean;
  actionUrl?: string;
  metadata?: any;
  createdAt: string;
  readAt?: string;
  dismissedAt?: string;
  expiresAt?: string;
}

interface NotificationPreferences {
  category: string;
  enabled: boolean;
  emailEnabled: boolean;
  pushEnabled: boolean;
  thresholdValue?: number;
}

interface UseNotifications {
  notifications: Notification[];
  unreadCount: number;
  preferences: NotificationPreferences[];
  isLoading: boolean;
  
  // Notification management
  markAsRead: (id: string) => Promise<void>;
  markAllAsRead: () => Promise<void>;
  dismissNotification: (id: string) => Promise<void>;
  deleteNotification: (id: string) => Promise<void>;
  
  // Preferences
  updatePreferences: (category: string, preferences: Partial<NotificationPreferences>) => Promise<void>;
  
  // Manual notifications
  createNotification: (notification: Partial<Notification>) => Promise<void>;
  
  // Real-time
  subscribeToNotifications: () => void;
  unsubscribeFromNotifications: () => void;
}

export const useNotifications = (): UseNotifications => {
  const [notifications, setNotifications] = useState<Notification[]>([]);
  const [preferences, setPreferences] = useState<NotificationPreferences[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [subscription, setSubscription] = useState<any>(null);

  useEffect(() => {
    const initializeNotifications = async () => {
      try {
        await fetchNotifications();
        await fetchPreferences();
        subscribeToNotifications();
      } catch (error) {
        console.error('Error initializing notifications:', error);
        // Set loading to false even on error to prevent infinite loading
        setIsLoading(false);
      }
    };
    
    initializeNotifications();
    
    return () => {
      unsubscribeFromNotifications();
    };
  }, []);

  const fetchNotifications = async () => {
    try {
      const { data: { user }, error: authError } = await supabase.auth.getUser();
      if (authError) {
        console.error('Auth error:', authError);
        setIsLoading(false);
        return;
      }
      
      if (!user) {
        // User not authenticated, set empty state
        setNotifications([]);
        setIsLoading(false);
        return;
      }

      // Check if notifications table exists before querying
      const { data, error } = await supabase
        .from('notifications')
        .select('*')
        .eq('user_id', user.id)
        .order('created_at', { ascending: false })
        .limit(50);

      if (error) {
        console.error('Error fetching notifications:', error);
        // Set empty notifications if table doesn't exist or other error
        setNotifications([]);
      } else {
        const transformedNotifications = data?.map(notif => ({
          id: notif.id,
          title: notif.title,
          message: notif.message,
          type: notif.type,
          category: notif.category,
          priority: notif.priority,
          isRead: notif.is_read,
          autoGenerated: notif.auto_generated,
          actionUrl: notif.action_url,
          metadata: notif.metadata,
          createdAt: notif.created_at,
          readAt: notif.read_at,
          dismissedAt: notif.dismissed_at,
          expiresAt: notif.expires_at,
        })) || [];

        setNotifications(transformedNotifications);
      }
    } catch (error) {
      console.error('Error fetching notifications:', error);
      setNotifications([]);
    } finally {
      setIsLoading(false);
    }
  };

  const fetchPreferences = async () => {
    try {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) return;

      const { data, error } = await supabase
        .from('notification_preferences')
        .select('*')
        .eq('user_id', user.id);

      if (error) {
        console.error('Error fetching preferences:', error);
        // Set default preferences if table doesn't exist
        setPreferences([]);
      } else {
        const transformedPreferences = data?.map(pref => ({
          category: pref.category,
          enabled: pref.enabled,
          emailEnabled: pref.email_enabled,
          pushEnabled: pref.push_enabled,
          thresholdValue: pref.threshold_value,
        })) || [];

        setPreferences(transformedPreferences);
      }
    } catch (error) {
      console.error('Error fetching preferences:', error);
      setPreferences([]);
    }
  };

  const markAsRead = useCallback(async (id: string) => {
    try {
      const { error } = await supabase
        .from('notifications')
        .update({ 
          is_read: true, 
          read_at: new Date().toISOString() 
        })
        .eq('id', id);

      if (error) throw error;

      setNotifications(prev => 
        prev.map(notif => 
          notif.id === id 
            ? { ...notif, isRead: true, readAt: new Date().toISOString() }
            : notif
        )
      );
    } catch (error) {
      console.error('Error marking notification as read:', error);
    }
  }, []);

  const markAllAsRead = useCallback(async () => {
    try {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) return;

      const { error } = await supabase
        .from('notifications')
        .update({ 
          is_read: true, 
          read_at: new Date().toISOString() 
        })
        .eq('user_id', user.id)
        .eq('is_read', false);

      if (error) throw error;

      setNotifications(prev => 
        prev.map(notif => ({ 
          ...notif, 
          isRead: true, 
          readAt: new Date().toISOString() 
        }))
      );

      toast.success('Todas as notificações marcadas como lidas');
    } catch (error) {
      console.error('Error marking all as read:', error);
      toast.error('Erro ao marcar notificações como lidas');
    }
  }, []);

  const dismissNotification = useCallback(async (id: string) => {
    try {
      const { error } = await supabase
        .from('notifications')
        .update({ 
          dismissed_at: new Date().toISOString() 
        })
        .eq('id', id);

      if (error) throw error;

      setNotifications(prev => 
        prev.filter(notif => notif.id !== id)
      );
    } catch (error) {
      console.error('Error dismissing notification:', error);
    }
  }, []);

  const deleteNotification = useCallback(async (id: string) => {
    try {
      const { error } = await supabase
        .from('notifications')
        .delete()
        .eq('id', id);

      if (error) throw error;

      setNotifications(prev => 
        prev.filter(notif => notif.id !== id)
      );

      toast.success('Notificação excluída');
    } catch (error) {
      console.error('Error deleting notification:', error);
      toast.error('Erro ao excluir notificação');
    }
  }, []);

  const updatePreferences = useCallback(async (category: string, newPreferences: Partial<NotificationPreferences>) => {
    try {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) return;

      const { error } = await supabase
        .from('notification_preferences')
        .upsert({
          user_id: user.id,
          category: category,
          enabled: newPreferences.enabled,
          email_enabled: newPreferences.emailEnabled,
          push_enabled: newPreferences.pushEnabled,
          threshold_value: newPreferences.thresholdValue,
        });

      if (error) throw error;

      setPreferences(prev => 
        prev.map(pref => 
          pref.category === category 
            ? { ...pref, ...newPreferences }
            : pref
        )
      );

      toast.success('Preferências atualizadas');
    } catch (error) {
      console.error('Error updating preferences:', error);
      toast.error('Erro ao atualizar preferências');
    }
  }, []);

  const createNotification = useCallback(async (notification: Partial<Notification>) => {
    try {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) return;

      const { error } = await supabase
        .from('notifications')
        .insert({
          user_id: user.id,
          title: notification.title,
          message: notification.message,
          type: notification.type || 'info',
          category: notification.category || 'general',
          priority: notification.priority || 'normal',
          action_url: notification.actionUrl,
          metadata: notification.metadata,
          auto_generated: false,
        });

      if (error) throw error;

      await fetchNotifications();
      toast.success('Notificação criada');
    } catch (error) {
      console.error('Error creating notification:', error);
      toast.error('Erro ao criar notificação');
    }
  }, []);

  const subscribeToNotifications = useCallback(() => {
    supabase.auth.getUser().then(({ data: { user: currentUser }, error }) => {
      if (error || !currentUser) return;

      const channel = supabase
        .channel('notifications')
        .on(
          'postgres_changes',
          {
            event: 'INSERT',
            schema: 'public',
            table: 'notifications',
            filter: `user_id=eq.${currentUser.id}`,
          },
          (payload) => {
            const newNotification = {
              id: payload.new.id,
              title: payload.new.title,
              message: payload.new.message,
              type: payload.new.type,
              category: payload.new.category,
              priority: payload.new.priority,
              isRead: payload.new.is_read,
              autoGenerated: payload.new.auto_generated,
              actionUrl: payload.new.action_url,
              metadata: payload.new.metadata,
              createdAt: payload.new.created_at,
              readAt: payload.new.read_at,
              dismissedAt: payload.new.dismissed_at,
              expiresAt: payload.new.expires_at,
            };

            setNotifications(prev => [newNotification, ...prev]);

            // Mostrar toast para notificações importantes
            if (newNotification.priority === 'urgent' || newNotification.priority === 'high') {
              toast(newNotification.message, {
                icon: newNotification.type === 'error' ? '🚨' : 
                     newNotification.type === 'warning' ? '⚠️' : 
                     newNotification.type === 'success' ? '🎉' : 'ℹ️',
                duration: 5000,
              });
            }
          }
        )
        .subscribe();

      setSubscription(channel);
    });
  }, []);

  const unsubscribeFromNotifications = useCallback(() => {
    if (subscription) {
      supabase.removeChannel(subscription);
      setSubscription(null);
    }
  }, [subscription]);

  const unreadCount = notifications.filter(n => !n.isRead && !n.dismissedAt).length;

  return {
    notifications: notifications.filter(n => !n.dismissedAt),
    unreadCount,
    preferences,
    isLoading,
    markAsRead,
    markAllAsRead,
    dismissNotification,
    deleteNotification,
    updatePreferences,
    createNotification,
    subscribeToNotifications,
    unsubscribeFromNotifications,
  };
};